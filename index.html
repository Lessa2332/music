<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è | –ó–∞–¥—É–π —Å–≤—ñ—á–∫—É</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: white;
    }
    #video, #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }

    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: white;
      text-align: center;
      padding: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid white;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    #wishText {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: #FFD700;
      padding: 15px 25px;
      border-radius: 20px;
      font-size: 1.3em;
      font-weight: bold;
      z-index: 85;
      text-align: center;
      border: 2px solid #FFD700;
      display: none;
      max-width: 90%;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    #handIndicator {
      position: fixed;
      top: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 12px 20px;
      border-radius: 20px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      display: none;
      align-items: center;
      gap: 10px;
      z-index: 99;
      font-size: 16px;
      backdrop-filter: blur(10px);
    }

    #flameStatus {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 69, 0, 0.9);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 16px;
      z-index: 100;
      display: none;
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 0 15px rgba(255, 69, 0, 0.7);
    }

    #micBtn {
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(255, 69, 0, 0.9);
      border: 3px solid #FFD700;
      color: white;
      font-size: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      box-shadow: 0 0 25px rgba(255, 69, 0, 0.8);
      transition: all 0.3s ease;
    }
    #micBtn:hover {
      transform: translateX(-50%) scale(1.1);
      box-shadow: 0 0 35px rgba(255, 69, 0, 1);
    }

    @keyframes spin { 
      0% { transform: rotate(0deg); } 
      100% { transform: rotate(360deg); } 
    }
    @keyframes flameFlicker {
      0%, 100% { 
        transform: translateY(0) scale(1); 
        opacity: 0.9; 
      }
      25% { 
        transform: translateY(-2px) scale(1.1); 
        opacity: 1; 
      }
      50% { 
        transform: translateY(1px) scale(0.95); 
        opacity: 0.8; 
      }
      75% { 
        transform: translateY(-1px) scale(1.05); 
        opacity: 0.95; 
      }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div>üéÇ –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    <p style="margin-top: 20px; color: rgba(255,255,255,0.8);">–ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</p>
  </div>

  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>

  <div id="wishText">üéÇ –ó–∞–≥–∞–¥–∞–π –±–∞–∂–∞–Ω–Ω—è —Ç–∞ –∑–∞–¥—É–π —Å–≤—ñ—á–∫—É! üí®</div>
  <div id="flameStatus">üî• –ü–æ–ª—É–º'—è –ø–∞–ª–∞—î</div>
  <div id="handIndicator">üëã –ü–æ–∫–∞–∂—ñ—Ç—å –¥–æ–ª–æ–Ω—é –∫–∞–º–µ—Ä—ñ</div>
  <button id="micBtn">üé§</button>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

    // –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—è
    const CONFIG = {
      SMOOTHING_FACTOR: 0.6,
      HAND_NOT_DETECTED_THRESHOLD: 30,
      CAKE_SCALE: 0.15,
      CANDLE_HEIGHT: 0.3,
      FLAME_HEIGHT: 0.4,
      FLAME_BLOWOUT_THRESHOLD: 0.35
    };

    // –°—Ç–∞–Ω –¥–æ–¥–∞—Ç–∫—É
    const state = {
      landmarks: null,
      isHandVisible: false,
      handFrames: 0,
      isFlameLit: true,
      isMicActive: false,
      audioContext: null,
      analyser: null,
      animationId: null,
      time: 0
    };

    // DOM –µ–ª–µ–º–µ–Ω—Ç–∏
    const elements = {
      video: document.getElementById('video'),
      canvas: document.getElementById('canvas'),
      loading: document.getElementById('loading'),
      wishText: document.getElementById('wishText'),
      flameStatus: document.getElementById('flameStatus'),
      handIndicator: document.getElementById('handIndicator'),
      micBtn: document.getElementById('micBtn')
    };

    // Three.js –∑–º—ñ–Ω–Ω—ñ
    let scene, camera, renderer;
    let cakeSprite, candle, flame;
    let handLandmarker;

    class CakeARApp {
      constructor() {
        this.init();
      }

      async init() {
        try {
          await this.setupCamera();
          await this.initThreeJS();
          await this.initHandTracking();
          this.setupEventListeners();
          this.hideLoading();
          this.startAnimation();
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó:', error);
          this.showError('–ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É —Ç–∞ –¥–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async setupCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: {
              facingMode: 'environment',
              width: { ideal: 1280 },
              height: { ideal: 720 }
            }
          });
          elements.video.srcObject = stream;
          await new Promise(resolve => {
            elements.video.onloadedmetadata = () => {
              elements.video.play();
              resolve();
            };
          });
        } catch (error) {
          throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏');
        }
      }

      async initThreeJS() {
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å—Ü–µ–Ω—É
        scene = new THREE.Scene();
        
        // –ö–∞–º–µ—Ä–∞
        camera = new THREE.PerspectiveCamera(
          60, 
          window.innerWidth / window.innerHeight, 
          0.1, 
          1000
        );
        camera.position.set(0, 0, 5);
        
        // –†–µ–Ω–¥–µ—Ä–µ—Ä
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        
        // –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ PNG —Ç–æ—Ä—Ç–∞ —è–∫ —Å–ø—Ä–∞–π—Ç
        await this.loadCakeSprite();
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å–≤—ñ—á–∫—É –∑ –ø–æ–ª—É–º'—è–º
        this.createCandle();
      }

      async loadCakeSprite() {
        return new Promise((resolve) => {
          const textureLoader = new THREE.TextureLoader();
          
          textureLoader.load(
            'foto.png',
            (texture) => {
              // –°—Ç–≤–æ—Ä—é—î–º–æ —Å–ø—Ä–∞–π—Ç –∑ —Ç–µ–∫—Å—Ç—É—Ä–æ—é —Ç–æ—Ä—Ç–∞
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: false
              });
              
              cakeSprite = new THREE.Sprite(spriteMaterial);
              cakeSprite.scale.set(2, 2, 1); // –ú–∞—Å—à—Ç–∞–± —Å–ø—Ä–∞–π—Ç–∞
              cakeSprite.visible = false;
              scene.add(cakeSprite);
              resolve();
            },
            undefined,
            (error) => {
              console.error('–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–æ—Ç–æ:', error);
              // –°—Ç–≤–æ—Ä—é—î–º–æ –∑–∞–ø–∞—Å–Ω–∏–π —Å–ø—Ä–∞–π—Ç
              this.createFallbackSprite();
              resolve();
            }
          );
        });
      }

      createFallbackSprite() {
        // –°—Ç–≤–æ—Ä—é—î–º–æ –ø—Ä–æ—Å—Ç–∏–π —Å–ø—Ä–∞–π—Ç —è–∫ –∑–∞–ø–∞—Å–Ω–∏–π –≤–∞—Ä—ñ–∞–Ω—Ç
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // –ì—Ä–∞–¥—ñ—î–Ω—Ç–Ω–∏–π —Ñ–æ–Ω
        const gradient = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
        gradient.addColorStop(0, '#ff9a9e');
        gradient.addColorStop(1, '#fad0c4');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 256);
        
        // –¢–µ–∫—Å—Ç —Ç–æ—Ä—Ç–∞
        ctx.fillStyle = 'white';
        ctx.font = 'bold 60px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üéÇ', 128, 128);
        
        const texture = new THREE.CanvasTexture(canvas);
        const spriteMaterial = new THREE.SpriteMaterial({ 
          map: texture,
          transparent: true
        });
        
        cakeSprite = new THREE.Sprite(spriteMaterial);
        cakeSprite.scale.set(2, 2, 1);
        cakeSprite.visible = false;
        scene.add(cakeSprite);
      }

      createCandle() {
        // –°–≤—ñ—á–∫–∞ (–±—ñ–ª–∏–π —Ü–∏–ª—ñ–Ω–¥—Ä)
        const candleGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.3, 16);
        const candleMaterial = new THREE.MeshPhongMaterial({ 
          color: 0xffffff,
          shininess: 100,
          specular: 0x222222
        });
        candle = new THREE.Mesh(candleGeometry, candleMaterial);
        candle.position.y = 1.2; // –í–∏—â–µ —Ç–æ—Ä—Ç–∞
        candle.visible = false;
        scene.add(candle);
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ —Å–∫–ª–∞–¥–Ω–µ –ø–æ–ª—É–º'—è –∑ —Ç—Ä—å–æ–º–∞ —à–∞—Ä–∞–º–∏
        this.createComplexFlame();
        
        // –°–≤—ñ—Ç–ª–æ –≤—ñ–¥ –ø–æ–ª—É–º'—è
        const flameLight = new THREE.PointLight(0xff5500, 2, 3);
        flameLight.position.set(0, 1.6, 0);
        flameLight.visible = false;
        scene.add(flameLight);
        candle.add(flameLight);
      }

      createComplexFlame() {
        // –ì—Ä—É–ø–∞ –¥–ª—è –ø–æ–ª—É–º'—è
        flame = new THREE.Group();
        flame.position.y = 1.5; // –ù–∞–¥ —Å–≤—ñ—á–∫–æ—é
        flame.visible = false;
        
        // –í–Ω—É—Ç—Ä—ñ—à–Ω—î –ø–æ–ª—É–º'—è (–∂–æ–≤—Ç–µ)
        const innerFlameGeometry = new THREE.ConeGeometry(0.06, 0.25, 16);
        const innerFlameMaterial = new THREE.MeshPhongMaterial({
          color: 0xffff00,
          emissive: 0xffaa00,
          emissiveIntensity: 1.5,
          transparent: true,
          opacity: 0.9
        });
        const innerFlame = new THREE.Mesh(innerFlameGeometry, innerFlameMaterial);
        
        // –°–µ—Ä–µ–¥–Ω—î –ø–æ–ª—É–º'—è (–æ—Ä–∞–Ω–∂–µ–≤–µ)
        const middleFlameGeometry = new THREE.ConeGeometry(0.08, 0.3, 16);
        const middleFlameMaterial = new THREE.MeshPhongMaterial({
          color: 0xff8800,
          emissive: 0xff6600,
          emissiveIntensity: 1.2,
          transparent: true,
          opacity: 0.7
        });
        const middleFlame = new THREE.Mesh(middleFlameGeometry, middleFlameMaterial);
        middleFlame.position.y = -0.02;
        
        // –ó–æ–≤–Ω—ñ—à–Ω—î –ø–æ–ª—É–º'—è (—á–µ—Ä–≤–æ–Ω–µ)
        const outerFlameGeometry = new THREE.ConeGeometry(0.1, 0.35, 16);
        const outerFlameMaterial = new THREE.MeshPhongMaterial({
          color: 0xff3300,
          emissive: 0xff2200,
          emissiveIntensity: 1.0,
          transparent: true,
          opacity: 0.5
        });
        const outerFlame = new THREE.Mesh(outerFlameGeometry, outerFlameMaterial);
        outerFlame.position.y = -0.04;
        
        // –î–æ–¥–∞—î–º–æ –≤—Å—ñ —à–∞—Ä–∏ –¥–æ –≥—Ä—É–ø–∏
        flame.add(innerFlame);
        flame.add(middleFlame);
        flame.add(outerFlame);
        
        candle.add(flame);
      }

      async initHandTracking() {
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      setupEventListeners() {
        elements.micBtn.addEventListener('click', () => this.toggleMicrophone());
        window.addEventListener('resize', () => this.onWindowResize());
      }

      toggleMicrophone() {
        if (state.isMicActive) {
          this.stopMicrophone();
          elements.micBtn.style.background = 'rgba(255, 69, 0, 0.9)';
        } else {
          this.startMicrophone();
          elements.micBtn.style.background = '#4CAF50';
        }
      }

      async startMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: true
          });
          
          state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const source = state.audioContext.createMediaStreamSource(stream);
          state.analyser = state.audioContext.createAnalyser();
          state.analyser.fftSize = 256;
          state.analyser.smoothingTimeConstant = 0.3;
          source.connect(state.analyser);
          
          state.isMicActive = true;
          
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞:', error);
          alert('–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –º—ñ–∫—Ä–æ—Ñ–æ–Ω–∞ –¥–ª—è –∑–∞–¥—É–≤–∞–Ω–Ω—è —Å–≤—ñ—á–∫–∏');
        }
      }

      stopMicrophone() {
        if (state.audioContext) {
          state.audioContext.close();
        }
        state.analyser = null;
        state.isMicActive = false;
      }

      checkMicrophoneVolume() {
        if (!state.isMicActive || !state.analyser || !state.isFlameLit) return false;
        
        const dataArray = new Uint8Array(state.analyser.frequencyBinCount);
        state.analyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
          sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        const volume = average / 255;
        
        return volume > CONFIG.FLAME_BLOWOUT_THRESHOLD;
      }

      startAnimation() {
        const animate = () => {
          state.time += 0.016; // ~60 FPS
          this.update();
          this.render();
          state.animationId = requestAnimationFrame(animate);
        };
        animate();
      }

      update() {
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ –ø–æ–ª–æ–∂–µ–Ω–Ω—è —Ä—É–∫–∏
        this.detectHand();
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ–ª–æ–∂–µ–Ω–Ω—è —Ç–æ—Ä—Ç–∞ —Ç–∞ —Å–≤—ñ—á–∫–∏
        if (state.landmarks && state.isHandVisible) {
          this.updatePosition();
          
          if (!cakeSprite.visible) {
            cakeSprite.visible = true;
            candle.visible = state.isFlameLit;
            flame.visible = state.isFlameLit;
            elements.wishText.style.display = 'block';
            elements.flameStatus.style.display = 'block';
            elements.handIndicator.style.display = 'none';
          }
        } else {
          if (cakeSprite.visible) {
            cakeSprite.visible = false;
            candle.visible = false;
            flame.visible = false;
            elements.wishText.style.display = 'none';
            elements.flameStatus.style.display = 'none';
          }
          
          if (state.handFrames > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
            elements.handIndicator.style.display = 'flex';
          }
        }
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è –ø–æ–ª—É–º'—è
        if (state.isFlameLit && flame.visible) {
          this.animateFlame();
        }
        
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –∑–∞–¥—É–ª–∏ —Å–≤—ñ—á–∫—É
        if (this.checkMicrophoneVolume() && state.isFlameLit) {
          this.blowOutCandle();
        }
      }

      detectHand() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        
        try {
          const results = handLandmarker.detectForVideo(elements.video, performance.now());
          
          if (results.landmarks && results.landmarks.length > 0) {
            state.landmarks = results.landmarks[0];
            state.isHandVisible = true;
            state.handFrames = 0;
          } else {
            state.landmarks = null;
            state.isHandVisible = false;
            state.handFrames++;
          }
        } catch (error) {
          console.error('–ü–æ–º–∏–ª–∫–∞ —Ä–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è —Ä—É–∫–∏:', error);
        }
      }

      updatePosition() {
        if (!state.landmarks) return;
        
        // –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ü–µ–Ω—Ç—Ä –¥–æ–ª–æ–Ω—ñ (—Å–µ—Ä–µ–¥–Ω—î –º—ñ–∂ —Ç–æ—á–∫–∞–º–∏)
        const points = [
          state.landmarks[0],  // –∑–∞–ø'—è—Å—Ç—è
          state.landmarks[5],  // –æ—Å–Ω–æ–≤–∞ –≤–∫–∞–∑—ñ–≤–Ω–æ–≥–æ
          state.landmarks[9],  // –æ—Å–Ω–æ–≤–∞ —Å–µ—Ä–µ–¥–Ω—å–æ–≥–æ
          state.landmarks[13], // –æ—Å–Ω–æ–≤–∞ –±–µ–∑—ñ–º–µ–Ω–Ω–æ–≥–æ
          state.landmarks[17]  // –æ—Å–Ω–æ–≤–∞ –º—ñ–∑–∏–Ω—Ü—è
        ];
        
        let centerX = 0, centerY = 0;
        for (const point of points) {
          centerX += point.x;
          centerY += point.y;
        }
        centerX /= points.length;
        centerY /= points.length;
        
        // –ö–æ–Ω–≤–µ—Ä—Ç—É—î–º–æ –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ Three.js
        const x = (centerX - 0.5) * 8; // –ú–∞—Å—à—Ç–∞–±—É—î–º–æ
        const y = (0.5 - centerY) * 6; // –Ü–Ω–≤–µ—Ä—Ç—É—î–º–æ Y
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Ç–æ—Ä—Ç
        if (cakeSprite) {
          cakeSprite.position.set(x, y - 0.5, 0);
          cakeSprite.lookAt(camera.position);
        }
        
        // –ü–æ–∑–∏—Ü—ñ–æ–Ω—É—î–º–æ —Å–≤—ñ—á–∫—É
        if (candle) {
          candle.position.set(x, y + 0.3, 0); // –í–∏—â–µ —Ç–æ—Ä—Ç–∞
          candle.lookAt(camera.position);
        }
      }

      animateFlame() {
        if (!flame) return;
        
        // –ê–Ω—ñ–º–∞—Ü—ñ—è –∫–æ–ª–∏–≤–∞–Ω–Ω—è
        const time = state.time;
        
        // –†—ñ–∑–Ω—ñ —á–∞—Å—Ç–æ—Ç–∏ –¥–ª—è –ø—Ä–∏—Ä–æ–¥–Ω–æ–≥–æ –≤–∏–≥–ª—è–¥—É
        const scale1 = 1 + Math.sin(time * 12) * 0.1;
        const scale2 = 1 + Math.sin(time * 8 + 1) * 0.08;
        const scale3 = 1 + Math.sin(time * 10 + 2) * 0.06;
        
        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–µ –∫–æ–ª–∏–≤–∞–Ω–Ω—è
        const offsetY = Math.sin(time * 6) * 0.05;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ –∫–æ–∂–µ–Ω —à–∞—Ä –ø–æ–ª—É–º'—è
        if (flame.children[0]) {
          flame.children[0].scale.set(scale1, scale1, scale1);
          flame.children[0].position.y = offsetY;
        }
        if (flame.children[1]) {
          flame.children[1].scale.set(scale2, scale2, scale2);
          flame.children[1].position.y = offsetY - 0.02;
        }
        if (flame.children[2]) {
          flame.children[2].scale.set(scale3, scale3, scale3);
          flame.children[2].position.y = offsetY - 0.04;
        }
        
        // –û–±–µ—Ä—Ç–∞–Ω–Ω—è –¥–ª—è –µ—Ñ–µ–∫—Ç—É –∂–∏–≤–æ–≥–æ –≤–æ–≥–Ω—é
        flame.rotation.z = Math.sin(time * 3) * 0.1;
      }

      blowOutCandle() {
        state.isFlameLit = false;
        flame.visible = false;
        
        // –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å
        elements.flameStatus.textContent = 'üéâ –ë–∞–∂–∞–Ω–Ω—è –∑–±—É–ª–æ—Å—è!';
        elements.flameStatus.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        elements.flameStatus.style.boxShadow = '0 0 15px rgba(76, 175, 80, 0.7)';
        
        // –ï—Ñ–µ–∫—Ç –∑–∞–¥—É–≤–∞–Ω–Ω—è
        this.createBlowEffect();
        
        // –ß–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥–∏ –∑–∞–ø–∞–ª—é—î–º–æ –∑–Ω–æ–≤—É
        setTimeout(() => {
          this.relightCandle();
        }, 3000);
      }

      createBlowEffect() {
        // –ü—Ä–æ—Å—Ç–∏–π –µ—Ñ–µ–∫—Ç –∑–∞–¥—É–≤–∞–Ω–Ω—è
        const originalText = elements.wishText.textContent;
        elements.wishText.textContent = 'üí® –°–≤—ñ—á–∫–∞ –∑–∞–¥—É—Ç–∞! üéâ';
        elements.wishText.style.color = '#4CAF50';
        
        setTimeout(() => {
          elements.wishText.textContent = originalText;
          elements.wishText.style.color = '#FFD700';
        }, 2000);
      }

      relightCandle() {
        state.isFlameLit = true;
        flame.visible = true;
        
        elements.flameStatus.textContent = 'üî• –ü–æ–ª—É–º\'—è –ø–∞–ª–∞—î';
        elements.flameStatus.style.background = 'linear-gradient(135deg, #ff4500 0%, #ff6347 100%)';
        elements.flameStatus.style.boxShadow = '0 0 15px rgba(255, 69, 0, 0.7)';
      }

      render() {
        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      onWindowResize() {
        if (camera && renderer) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
        elements.handIndicator.style.display = 'flex';
      }

      showError(message) {
        elements.loading.innerHTML = `
          <div style="color: #ff6b6b; font-size: 24px; margin-bottom: 20px;">üòï</div>
          <div style="margin-bottom: 20px;">${message}</div>
          <button onclick="location.reload()" style="padding: 12px 24px; background: #ff6b95; color: white; border: none; border-radius: 25px; cursor: pointer;">
            –°–ø—Ä–æ–±—É–≤–∞—Ç–∏ –∑–Ω–æ–≤—É
          </button>
        `;
      }

      cleanup() {
        if (state.animationId) {
          cancelAnimationFrame(state.animationId);
        }
        if (elements.video.srcObject) {
          elements.video.srcObject.getTracks().forEach(track => track.stop());
        }
        if (handLandmarker) {
          handLandmarker.close();
        }
        this.stopMicrophone();
      }
    }

    // –ó–∞–ø—É—Å–∫ –¥–æ–¥–∞—Ç–∫—É
    window.addEventListener('DOMContentLoaded', () => {
      const app = new CakeARApp();
      window.addEventListener('beforeunload', () => app.cleanup());
    });
  </script>
</body>
</html>
